/*
 * HSPatch Universal Frida Script v3.0
 * - SSL Certificate Pinning Bypass
 * - Signature Verification Bypass (runtime layer)
 * - Piracy / License / Integrity Checks Removal
 * - Screenshot / Recording FLAG_SECURE Bypass
 * - Network Traffic Monitoring, Blocking & Modification
 */

setTimeout(function() {
    Java.perform(function() {
        var TAG = "HSPatch-Frida";

        console.log('');
        console.log('======================================================');
        console.log('[#] HSPatch Universal Bypass Suite v3.0               [#]');
        console.log('======================================================');

        // =====================================================
        // 1. SSL CERTIFICATE PINNING BYPASS
        // =====================================================

        // TrustManagerImpl
        try {
            var array_list = Java.use('java.util.ArrayList');
            var TrustManagerImpl = Java.use('com.android.org.conscrypt.TrustManagerImpl');
            TrustManagerImpl.checkTrustedRecursive.implementation = function(a, b, c, d, e, f, g, h) {
                console.log('[+] SSL: Bypassing TrustManagerImpl for: ' + b);
                return array_list.$new();
            };
        } catch (err) {
            console.log('[-] TrustManagerImpl not found');
        }

        // OpenSSLSocketImpl
        try {
            var OpenSSLSocketImpl = Java.use('com.android.org.conscrypt.OpenSSLSocketImpl');
            OpenSSLSocketImpl.verifyCertificateChain.implementation = function(g, i) {
                console.log('[+] SSL: Bypassing OpenSSLSocketImpl');
            };
        } catch (err) {
            console.log('[-] OpenSSLSocketImpl not found');
        }

        // OkHttp3 CertificatePinner
        try {
            var CertPinner = Java.use('okhttp3.CertificatePinner');
            CertPinner.check.overload('java.lang.String', 'java.util.List').implementation = function(hostname, peerCerts) {
                console.log('[+] SSL: Bypassing OkHttp3 CertificatePinner for: ' + hostname);
            };
        } catch (err) { }

        try {
            var CertPinner2 = Java.use('okhttp3.CertificatePinner');
            CertPinner2['check$okhttp'].implementation = function(hostname, fn) {
                console.log('[+] SSL: Bypassing OkHttp3 CertificatePinner$okhttp for: ' + hostname);
            };
        } catch (err) { }

        // TrustManagerFactory
        try {
            var TrustManagerFactory = Java.use('javax.net.ssl.TrustManagerFactory');
            TrustManagerFactory.getTrustManagers.implementation = function() {
                var EmptyTrustManager = Java.registerClass({
                    name: 'com.hspatch.TrustAllManager',
                    implements: [Java.use('javax.net.ssl.X509TrustManager')],
                    methods: {
                        checkClientTrusted: function(chain, authType) {},
                        checkServerTrusted: function(chain, authType) {},
                        getAcceptedIssuers: function() { return []; }
                    }
                });
                return [EmptyTrustManager.$new()];
            };
        } catch (err) { }

        // HttpsURLConnection default hostname verifier
        try {
            var HostnameVerifier = Java.registerClass({
                name: 'com.hspatch.GlobalHostnameVerifier',
                implements: [Java.use('javax.net.ssl.HostnameVerifier')],
                methods: {
                    verify: function(hostname, session) { return true; }
                }
            });
            var HttpsURLConnection = Java.use('javax.net.ssl.HttpsURLConnection');
            HttpsURLConnection.setDefaultHostnameVerifier.implementation = function(verifier) {
                this.setDefaultHostnameVerifier(HostnameVerifier.$new());
            };
        } catch (err) { }

        console.log('[*] SSL Pinning bypass hooks installed');


        // =====================================================
        // 2. SIGNATURE VERIFICATION BYPASS (Runtime Layer)
        // =====================================================

        // Hook PackageManager.getPackageInfo to fix signatures
        try {
            var PM = Java.use('android.app.ApplicationPackageManager');

            PM.getPackageInfo.overload('java.lang.String', 'int').implementation = function(name, flags) {
                var pi = this.getPackageInfo(name, flags);

                // Only patch our own package
                var ctx = Java.use('android.app.ActivityThread').currentApplication();
                if (ctx !== null && name === ctx.getPackageName()) {
                    if ((flags & 0x40) !== 0 || (flags & 0x8000000) !== 0) {
                        try {
                            var storedSigs = Java.use('in.startv.hotstar.SignatureBypass').originalSignatures.value;
                            if (storedSigs !== null) {
                                pi.signatures.value = storedSigs;
                                console.log('[+] SIG: Patched getPackageInfo signatures for ' + name);
                            }
                        } catch(e) {}
                    }
                }
                return pi;
            };
            console.log('[*] Signature bypass hooks installed');
        } catch (err) {
            console.log('[-] PackageManager signature hook: ' + err);
        }


        // =====================================================
        // 3. PIRACY / LICENSE / INTEGRITY CHECK REMOVAL
        // =====================================================

        // Google Play Licensing (LVL)
        try {
            var LicenseChecker = Java.use('com.google.android.vending.licensing.LicenseChecker');
            LicenseChecker.checkAccess.implementation = function(callback) {
                console.log('[+] PIRACY: Bypassing LicenseChecker.checkAccess');
                try { callback.allow(0x100); } catch(e) { callback.allow(); }
            };
        } catch (err) { }

        // Installer package check bypass
        try {
            var APM = Java.use('android.app.ApplicationPackageManager');
            APM.getInstallerPackageName.implementation = function(pkg) {
                console.log('[+] PIRACY: Spoofing installer to Play Store for: ' + pkg);
                return "com.android.vending";
            };
        } catch (err) { }

        // Debug detection bypass
        try {
            var Debug = Java.use('android.os.Debug');
            Debug.isDebuggerConnected.implementation = function() { return false; };
        } catch (err) { }

        // Root detection - block common su checks
        try {
            var Runtime = Java.use('java.lang.Runtime');
            var origExec = Runtime.exec.overload('java.lang.String');
            origExec.implementation = function(cmd) {
                if (cmd.indexOf('su') === 0 || cmd === 'which su' ||
                    cmd.indexOf('/system/xbin/su') !== -1 ||
                    cmd.indexOf('/system/bin/su') !== -1 ||
                    cmd.indexOf('busybox') !== -1) {
                    console.log('[+] ROOT: Blocking root detection exec: ' + cmd);
                    throw Java.use('java.io.IOException').$new('Permission denied');
                }
                return origExec.call(this, cmd);
            };
        } catch (err) { }

        // Root detection - hide known root paths
        try {
            var File = Java.use('java.io.File');
            var origExists = File.exists;
            File.exists.implementation = function() {
                var path = this.getAbsolutePath();
                var rootPaths = ['/system/app/Superuser.apk', '/system/xbin/su', '/system/bin/su',
                    '/sbin/su', '/data/local/xbin/su', '/data/local/bin/su',
                    '/su/bin/su', '/data/adb/magisk'];
                for (var i = 0; i < rootPaths.length; i++) {
                    if (path === rootPaths[i]) {
                        console.log('[+] ROOT: Hiding path: ' + path);
                        return false;
                    }
                }
                return origExists.call(this);
            };
        } catch (err) { }

        // Build.TAGS - release-keys
        try {
            var Build = Java.use('android.os.Build');
            var tags = Build.TAGS.value;
            if (tags && tags.indexOf('test-keys') !== -1) {
                Build.TAGS.value = 'release-keys';
                console.log('[+] ROOT: Changed Build.TAGS to release-keys');
            }
        } catch (err) { }

        console.log('[*] Piracy/License/Root bypass hooks installed');


        // =====================================================
        // 4. SCREENSHOT & RECORDING ENABLEMENT
        // =====================================================

        try {
            var Window = Java.use('android.view.Window');
            Window.setFlags.implementation = function(flags, mask) {
                var cleanFlags = flags & ~0x2000;
                var cleanMask = mask & ~0x2000;
                if (flags !== cleanFlags) {
                    console.log('[+] SCREEN: Stripped FLAG_SECURE from setFlags');
                }
                this.setFlags(cleanFlags, cleanMask);
            };

            Window.addFlags.implementation = function(flags) {
                var cleanFlags = flags & ~0x2000;
                if (flags !== cleanFlags) {
                    console.log('[+] SCREEN: Stripped FLAG_SECURE from addFlags');
                }
                this.addFlags(cleanFlags);
            };
        } catch (err) {
            console.log('[-] Window FLAG_SECURE hook: ' + err);
        }

        // SurfaceView.setSecure
        try {
            var SurfaceView = Java.use('android.view.SurfaceView');
            SurfaceView.setSecure.implementation = function(isSecure) {
                console.log('[+] SCREEN: Bypassing SurfaceView.setSecure(' + isSecure + ')');
                this.setSecure(false);
            };
        } catch (err) { }

        console.log('[*] Screenshot/Recording bypass hooks installed');


        // =====================================================
        // 5. NETWORK TRAFFIC BLOCKING, MODIFICATION & MONITORING
        // =====================================================

        var netLogTag = "HSPatch-Net";
        var Log = Java.use('android.util.Log');

        // --- Load blocking rules from per-app file or legacy blocking_hotstar.txt ---
        // Search order per location:
        //   1. blocking_<packageName>.txt  (per-app dedicated)
        //   2. blocking_rules.txt          (generic)
        //   3. blocking_hotstar.txt        (legacy compatibility)
        // Rules format: each line is "pattern:replacement"
        // If replacement is empty or "BLOCK", the request is fully blocked.
        // Otherwise, pattern is replaced with replacement in the URL.
        var blockRules = [];
        var blockPatterns = [];   // patterns with no replacement → full block
        var rewriteRules = [];   // patterns with replacement → URL rewrite

        function loadBlockingRules() {
            try {
                var ctx = Java.use('android.app.ActivityThread').currentApplication();
                if (ctx === null) return;

                var pkgName = ctx.getPackageName();

                // Build candidate file names (per-app first, then generic, then legacy)
                var fileNames = [
                    'blocking_' + pkgName + '.txt',
                    'blocking_rules.txt',
                    'blocking_hotstar.txt'
                ];

                // Build candidate directories
                var dirs = [];
                try {
                    var extDir = ctx.getExternalFilesDir(null);
                    if (extDir !== null) {
                        dirs.push(extDir.getAbsolutePath());
                    }
                } catch(e) {}
                try {
                    var dataDir = ctx.getApplicationInfo().dataDir.value;
                    dirs.push(dataDir + '/files');
                } catch(e) {}
                dirs.push('/storage/emulated/0/Download/hspatch_logs');

                var File = Java.use('java.io.File');
                var BufferedReader = Java.use('java.io.BufferedReader');
                var FileReader = Java.use('java.io.FileReader');

                // Try each directory × each filename, stop on first found
                // Try each filename × each directory — per-app file always prioritized
                var found = false;
                for (var fi = 0; fi < fileNames.length && !found; fi++) {
                    for (var di = 0; di < dirs.length && !found; di++) {
                        var fullPath = dirs[di] + '/' + fileNames[fi];
                        var f = File.$new(fullPath);
                        if (f.exists()) {
                            Log.i(netLogTag, '[RULES] Loading blocking rules from: ' + fullPath);
                            var reader = BufferedReader.$new(FileReader.$new(fullPath));
                            var line;
                            while ((line = reader.readLine()) !== null) {
                                var lineStr = line.toString().trim();
                                if (lineStr.length === 0 || lineStr.charAt(0) === '#') continue;

                                var sepIdx = lineStr.indexOf(':');
                                if (sepIdx > 0) {
                                    var pattern = lineStr.substring(0, sepIdx).trim();
                                    var replacement = lineStr.substring(sepIdx + 1).trim();
                                    if (replacement.length === 0 || replacement === 'BLOCK') {
                                        blockPatterns.push(pattern);
                                        Log.i(netLogTag, '[RULES]   BLOCK: ' + pattern);
                                    } else {
                                        rewriteRules.push({ from: pattern, to: replacement });
                                        Log.i(netLogTag, '[RULES]   REWRITE: ' + pattern + ' -> ' + replacement);
                                    }
                                } else {
                                    // No colon = treat entire line as a block pattern
                                    blockPatterns.push(lineStr);
                                    Log.i(netLogTag, '[RULES]   BLOCK: ' + lineStr);
                                }
                            }
                            reader.close();
                            Log.i(netLogTag, '[RULES] Loaded ' + blockPatterns.length + ' block rules + '
                                + rewriteRules.length + ' rewrite rules from ' + fileNames[fi]);
                            found = true;
                        }
                    }
                }
                if (blockPatterns.length === 0 && rewriteRules.length === 0) {
                    Log.i(netLogTag, '[RULES] No blocking rules file found (will only monitor)');
                }
            } catch (err) {
                Log.w(netLogTag, '[RULES] Failed to load rules: ' + err);
            }
        }

        // Reload rules periodically (every 60s) so user edits take effect
        function scheduleRuleReload() {
            setTimeout(function() {
                Java.perform(function() {
                    var oldBlock = blockPatterns.length;
                    var oldRewrite = rewriteRules.length;
                    blockPatterns = [];
                    rewriteRules = [];
                    loadBlockingRules();
                    if (blockPatterns.length !== oldBlock || rewriteRules.length !== oldRewrite) {
                        Log.i(netLogTag, '[RULES] Rules reloaded: ' + blockPatterns.length + ' block, '
                            + rewriteRules.length + ' rewrite');
                    }
                });
                scheduleRuleReload();
            }, 60000);
        }

        loadBlockingRules();
        scheduleRuleReload();

        // Check if a URL should be blocked (returns true if blocked)
        function shouldBlock(url) {
            for (var i = 0; i < blockPatterns.length; i++) {
                if (url.indexOf(blockPatterns[i]) !== -1) {
                    return blockPatterns[i];
                }
            }
            return null;
        }

        // Apply rewrite rules to URL, returns modified URL string
        function applyRewrites(url) {
            var modified = url;
            var changed = false;
            for (var i = 0; i < rewriteRules.length; i++) {
                if (modified.indexOf(rewriteRules[i].from) !== -1) {
                    modified = modified.split(rewriteRules[i].from).join(rewriteRules[i].to);
                    changed = true;
                }
            }
            return { url: modified, changed: changed };
        }

        function ensureNetworkLoggerInitialized() {
            try {
                var ctx = Java.use('android.app.ActivityThread').currentApplication();
                if (ctx === null) return;
                var NL = Java.use('in.startv.hotstar.NetworkLogger');
                NL.init(ctx);
            } catch (e) { }
        }

        function safeNetworkLoggerLog(line) {
            try {
                ensureNetworkLoggerInitialized();
                var NL = Java.use('in.startv.hotstar.NetworkLogger');
                NL.log(line);
            } catch (e) { }
        }

        function logRewritten(source, method, before, after) {
            Log.i(netLogTag, '[REWRITE] [' + source + '] ' + method + ' ' + before + ' -> ' + after);
            safeNetworkLoggerLog('[REWRITE] [' + source + '] ' + method + ' ' + before + ' -> ' + after);
        }

        // Log blocked request
        function logBlocked(source, method, url, pattern) {
            Log.i(netLogTag, '[BLOCKED] [' + source + '] ' + method + ' ' + url + ' (matched: ' + pattern + ')');
            // Also log to file via NetworkLogger if available
            try {
                ensureNetworkLoggerInitialized();
                var NL = Java.use('in.startv.hotstar.NetworkLogger');
                NL.log('[BLOCKED] [' + source + '] ' + method + ' ' + url + ' (matched: ' + pattern + ')');
            } catch(e) {}

            // Also log to blocked_urls.txt
            try {
                var HSConfig = Java.use('in.startv.hotstar.HSPatchConfig');
                var blockedPath = HSConfig.getFilePath('blocked_urls.txt');
                var fw = Java.use('java.io.FileWriter').$new(blockedPath, true);
                var ts = Java.use('java.text.SimpleDateFormat').$new('HH:mm:ss')
                    .format(Java.use('java.util.Date').$new());
                fw.write(ts + ' [' + source + '] ' + method + ' ' + url + '\n');
                fw.flush();
                fw.close();
            } catch(e2) {}
        }

        // ===== Hostname-level rewriting so rules apply to raw sockets / DNS / UDP too =====
        function rewriteHostIfNeeded(source, method, host) {
            if (host === null || host === undefined) return host;
            var hostStr = host.toString();
            if (hostStr.length === 0) return host;
            // Avoid rewriting full URLs passed to DNS APIs by accident
            if (hostStr.indexOf('://') !== -1 || hostStr.indexOf('/') !== -1) return host;

            var rewritten = applyRewrites(hostStr);
            if (rewritten.changed && rewritten.url !== hostStr) {
                logRewritten(source, method, hostStr, rewritten.url);
                return rewritten.url;
            }
            return host;
        }

        try {
            var InetAddress = Java.use('java.net.InetAddress');
            InetAddress.getByName.overload('java.lang.String').implementation = function(host) {
                var newHost = rewriteHostIfNeeded('InetAddress', 'getByName', host);
                return this.getByName(newHost);
            };
        } catch (err) { }

        try {
            var InetSocketAddress = Java.use('java.net.InetSocketAddress');
            InetSocketAddress.$init.overload('java.lang.String', 'int').implementation = function(host, port) {
                var newHost = rewriteHostIfNeeded('InetSocketAddress', 'init', host);
                return this.$init(newHost, port);
            };
        } catch (err) { }

        try {
            var DatagramPacket = Java.use('java.net.DatagramPacket');
            DatagramPacket.$init.overload('[B', 'int', 'java.lang.String', 'int').implementation = function(buf, length, host, port) {
                var newHost = rewriteHostIfNeeded('DatagramPacket', 'init', host);
                return this.$init(buf, length, newHost, port);
            };
        } catch (err) { }

        try {
            var SocketCtor = Java.use('java.net.Socket');
            SocketCtor.$init.overload('java.lang.String', 'int').implementation = function(host, port) {
                var newHost = rewriteHostIfNeeded('Socket', 'init', host);
                return this.$init(newHost, port);
            };
        } catch (err) { }

        // URL.openConnection() — block or rewrite before connection opens
        try {
            var URL = Java.use('java.net.URL');
            URL.openConnection.overload().implementation = function() {
                var url = this.toString();

                // Check block rules
                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('URL', 'OPEN', url, blockMatch);
                    // Return connection to localhost to effectively null-route
                    var nullUrl = Java.use('java.net.URL').$new('http://127.0.0.1:1/blocked');
                    return nullUrl.openConnection();
                }

                // Apply rewrite rules
                var rewritten = applyRewrites(url);
                if (rewritten.changed && rewritten.url !== url) {
                    logRewritten('URL', 'OPEN', url, rewritten.url);
                    var newUrl = Java.use('java.net.URL').$new(rewritten.url);
                    return newUrl.openConnection();
                }

                Log.i(netLogTag, 'OPEN ' + url);
                return this.openConnection();
            };

            // Also cover openConnection(Proxy)
            URL.openConnection.overload('java.net.Proxy').implementation = function(proxy) {
                var url = this.toString();

                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('URL', 'OPEN_PROXY', url, blockMatch);
                    var nullUrl = Java.use('java.net.URL').$new('http://127.0.0.1:1/blocked');
                    return nullUrl.openConnection(proxy);
                }

                var rewritten = applyRewrites(url);
                if (rewritten.changed && rewritten.url !== url) {
                    logRewritten('URL', 'OPEN_PROXY', url, rewritten.url);
                    var newUrl = Java.use('java.net.URL').$new(rewritten.url);
                    return newUrl.openConnection(proxy);
                }

                Log.i(netLogTag, 'OPEN_PROXY ' + url);
                return this.openConnection(proxy);
            };
        } catch (err) { }

        // OkHttp3 — intercept newCall, block or rewrite request URL
        try {
            var OkHttpClient = Java.use('okhttp3.OkHttpClient');
            OkHttpClient.newCall.implementation = function(request) {
                var url = request.url().toString();
                var method = request.method();

                // Check block rules
                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('OkHttp3', method, url, blockMatch);
                    // Build a new request to localhost to null-route
                    var Builder = Java.use('okhttp3.Request$Builder');
                    var HttpUrl = Java.use('okhttp3.HttpUrl');
                    var blockedUrl = HttpUrl.parse('http://127.0.0.1:1/blocked');
                    var blockedReq = request.newBuilder().url(blockedUrl).build();
                    return this.newCall(blockedReq);
                }

                // Apply rewrite rules
                var rewritten = applyRewrites(url);
                if (rewritten.changed && rewritten.url !== url) {
                    logRewritten('OkHttp3', method, url, rewritten.url);
                    var HttpUrl2 = Java.use('okhttp3.HttpUrl');
                    var newHttpUrl = HttpUrl2.parse(rewritten.url);
                    if (newHttpUrl !== null) {
                        var newReq = request.newBuilder().url(newHttpUrl).build();
                        return this.newCall(newReq);
                    }
                }

                Log.i(netLogTag, 'REQ ' + method + ' ' + url);
                return this.newCall(request);
            };
        } catch (err) { }

        // HttpURLConnection — block before connect
        try {
            var HttpURLConnection = Java.use('java.net.HttpURLConnection');
            HttpURLConnection.connect.implementation = function() {
                var url = this.getURL().toString();

                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('HttpConn', 'CONN', url, blockMatch);
                    // Throw IOException to prevent the connection
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                Log.i(netLogTag, 'CONN ' + url);
                this.connect();
            };
        } catch (err) { }

        // WebView URL — block before loading
        try {
            var WebView = Java.use('android.webkit.WebView');
            WebView.loadUrl.overload('java.lang.String').implementation = function(url) {
                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('WebView', 'LOAD', url, blockMatch);
                    // Load blank page instead
                    this.loadUrl('about:blank');
                    return;
                }

                var rewritten = applyRewrites(url);
                if (rewritten.changed && rewritten.url !== url) {
                    logRewritten('WebView', 'LOAD', url, rewritten.url);
                    this.loadUrl(rewritten.url);
                    return;
                }

                Log.i(netLogTag, 'WEBVIEW ' + url);
                this.loadUrl(url);
            };

            // loadUrl(String, Map) overload
            WebView.loadUrl.overload('java.lang.String', 'java.util.Map').implementation = function(url, headers) {
                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('WebView', 'LOAD_HEADERS', url, blockMatch);
                    this.loadUrl('about:blank');
                    return;
                }

                var rewritten = applyRewrites(url);
                if (rewritten.changed && rewritten.url !== url) {
                    logRewritten('WebView', 'LOAD_HEADERS', url, rewritten.url);
                    this.loadUrl(rewritten.url, headers);
                    return;
                }

                Log.i(netLogTag, 'WEBVIEW ' + url);
                this.loadUrl(url, headers);
            };

            // postUrl(String, byte[]) overload
            WebView.postUrl.overload('java.lang.String', '[B').implementation = function(url, postData) {
                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('WebView', 'POST', url, blockMatch);
                    this.loadUrl('about:blank');
                    return;
                }

                var rewritten = applyRewrites(url);
                if (rewritten.changed && rewritten.url !== url) {
                    logRewritten('WebView', 'POST', url, rewritten.url);
                    this.postUrl(rewritten.url, postData);
                    return;
                }

                Log.i(netLogTag, 'WEBVIEW.POST ' + url);
                this.postUrl(url, postData);
            };
        } catch (err) { }

        // Socket connect — block by host pattern (both overloads)
        try {
            var Socket = Java.use('java.net.Socket');
            Socket.connect.overload('java.net.SocketAddress', 'int').implementation = function(addr, timeout) {
                var addrStr = addr.toString();

                var blockMatch = shouldBlock(addrStr);
                if (blockMatch !== null) {
                    logBlocked('Socket', 'CONNECT', addrStr, blockMatch);
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                // Attempt rewrite for InetSocketAddress hostnames
                try {
                    var InetSocketAddress = Java.use('java.net.InetSocketAddress');
                    var isa = Java.cast(addr, InetSocketAddress);
                    var host = isa.getHostString ? isa.getHostString() : isa.getHostName();
                    var port = isa.getPort();
                    var newHost = rewriteHostIfNeeded('Socket', 'CONNECT', host);
                    if (newHost !== host) {
                        var newAddr = InetSocketAddress.$new(newHost, port);
                        Log.i(netLogTag, 'SOCKET ' + newHost + ':' + port);
                        this.connect(newAddr, timeout);
                        return;
                    }
                } catch (e) { }

                Log.i(netLogTag, 'SOCKET ' + addrStr);
                this.connect(addr, timeout);
            };
        } catch (err) { }

        try {
            var Socket2 = Java.use('java.net.Socket');
            Socket2.connect.overload('java.net.SocketAddress').implementation = function(addr) {
                var addrStr = addr.toString();

                var blockMatch = shouldBlock(addrStr);
                if (blockMatch !== null) {
                    logBlocked('Socket', 'CONNECT0', addrStr, blockMatch);
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                try {
                    var InetSocketAddress = Java.use('java.net.InetSocketAddress');
                    var isa = Java.cast(addr, InetSocketAddress);
                    var host = isa.getHostString ? isa.getHostString() : isa.getHostName();
                    var port = isa.getPort();
                    var newHost = rewriteHostIfNeeded('Socket', 'CONNECT0', host);
                    if (newHost !== host) {
                        var newAddr = InetSocketAddress.$new(newHost, port);
                        Log.i(netLogTag, 'SOCKET ' + newHost + ':' + port);
                        this.connect(newAddr);
                        return;
                    }
                } catch (e) { }

                Log.i(netLogTag, 'SOCKET ' + addrStr);
                this.connect(addr);
            };
        } catch (err) { }

        // SocketChannel.open(SocketAddress) — NIO socket blocking
        try {
            var SocketChannel = Java.use('java.nio.channels.SocketChannel');
            SocketChannel.open.overload('java.net.SocketAddress').implementation = function(addr) {
                var addrStr = addr.toString();

                var blockMatch = shouldBlock(addrStr);
                if (blockMatch !== null) {
                    logBlocked('SocketChannel', 'OPEN', addrStr, blockMatch);
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                try {
                    var InetSocketAddress = Java.use('java.net.InetSocketAddress');
                    var isa = Java.cast(addr, InetSocketAddress);
                    var host = isa.getHostString ? isa.getHostString() : isa.getHostName();
                    var port = isa.getPort();
                    var newHost = rewriteHostIfNeeded('SocketChannel', 'OPEN', host);
                    if (newHost !== host) {
                        var newAddr = InetSocketAddress.$new(newHost, port);
                        Log.i(netLogTag, 'SOCKETCHANNEL ' + newHost + ':' + port);
                        return this.open(newAddr);
                    }
                } catch (e) { }

                Log.i(netLogTag, 'SOCKETCHANNEL ' + addrStr);
                return this.open(addr);
            };
        } catch (err) { }

        // SocketChannel.connect(SocketAddress) — NIO channel connect
        try {
            var SocketChannel2 = Java.use('java.nio.channels.SocketChannel');
            SocketChannel2.connect.overload('java.net.SocketAddress').implementation = function(addr) {
                var addrStr = addr.toString();

                var blockMatch = shouldBlock(addrStr);
                if (blockMatch !== null) {
                    logBlocked('SocketChannel', 'CONNECT', addrStr, blockMatch);
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                try {
                    var InetSocketAddress = Java.use('java.net.InetSocketAddress');
                    var isa = Java.cast(addr, InetSocketAddress);
                    var host = isa.getHostString ? isa.getHostString() : isa.getHostName();
                    var port = isa.getPort();
                    var newHost = rewriteHostIfNeeded('SocketChannel', 'CONNECT', host);
                    if (newHost !== host) {
                        var newAddr = InetSocketAddress.$new(newHost, port);
                        Log.i(netLogTag, 'SOCKETCHANNEL.CONNECT ' + newHost + ':' + port);
                        return this.connect(newAddr);
                    }
                } catch (e) { }

                Log.i(netLogTag, 'SOCKETCHANNEL.CONNECT ' + addrStr);
                return this.connect(addr);
            };
        } catch (err) { }

        // DatagramSocket.connect — UDP socket blocking
        try {
            var DatagramSocket = Java.use('java.net.DatagramSocket');
            DatagramSocket.connect.overload('java.net.InetAddress', 'int').implementation = function(address, port) {
                var addrStr = address.getHostAddress() + ':' + port;

                var blockMatch = shouldBlock(addrStr);
                if (blockMatch !== null) {
                    logBlocked('DatagramSocket', 'CONNECT', addrStr, blockMatch);
                    throw Java.use('java.net.SocketException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                Log.i(netLogTag, 'UDP.CONNECT ' + addrStr);
                this.connect(address, port);
            };
        } catch (err) { }

        // DatagramSocket.send — UDP packet blocking
        try {
            var DatagramSocket2 = Java.use('java.net.DatagramSocket');
            DatagramSocket2.send.overload('java.net.DatagramPacket').implementation = function(packet) {
                var addr = packet.getAddress();
                if (addr !== null) {
                    var addrStr = addr.getHostAddress() + ':' + packet.getPort();

                    var blockMatch = shouldBlock(addrStr);
                    if (blockMatch !== null) {
                        logBlocked('DatagramSocket', 'SEND', addrStr, blockMatch);
                        throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                    }

                    Log.i(netLogTag, 'UDP.SEND ' + addrStr);
                }
                this.send(packet);
            };
        } catch (err) { }

        // SSLSocketFactory.createSocket — SSL socket blocking
        try {
            var SSLSocketFactory = Java.use('javax.net.ssl.SSLSocketFactory');
            SSLSocketFactory.createSocket.overload('java.lang.String', 'int').implementation = function(host, port) {
                var addrStr = host + ':' + port;

                var blockMatch = shouldBlock(addrStr);
                if (blockMatch !== null) {
                    logBlocked('SSLSocket', 'CREATE', addrStr, blockMatch);
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                var newHost = rewriteHostIfNeeded('SSLSocket', 'CREATE', host);
                if (newHost !== host) {
                    Log.i(netLogTag, 'SSL.CREATE ' + newHost + ':' + port);
                    return this.createSocket(newHost, port);
                }

                Log.i(netLogTag, 'SSL.CREATE ' + addrStr);
                return this.createSocket(host, port);
            };

            // Common overload used when TLS is layered on an existing Socket
            SSLSocketFactory.createSocket.overload('java.net.Socket', 'java.lang.String', 'int', 'boolean').implementation = function(sock, host, port, autoClose) {
                var addrStr = host + ':' + port;

                var blockMatch = shouldBlock(addrStr);
                if (blockMatch !== null) {
                    logBlocked('SSLSocket', 'CREATE_WRAP', addrStr, blockMatch);
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                var newHost = rewriteHostIfNeeded('SSLSocket', 'CREATE_WRAP', host);
                if (newHost !== host) {
                    Log.i(netLogTag, 'SSL.CREATE_WRAP ' + newHost + ':' + port);
                    return this.createSocket(sock, newHost, port, autoClose);
                }

                Log.i(netLogTag, 'SSL.CREATE_WRAP ' + addrStr);
                return this.createSocket(sock, host, port, autoClose);
            };

            // Bind-local variant with hostname
            SSLSocketFactory.createSocket.overload('java.lang.String', 'int', 'java.net.InetAddress', 'int').implementation = function(host, port, localAddr, localPort) {
                var addrStr = host + ':' + port;

                var blockMatch = shouldBlock(addrStr);
                if (blockMatch !== null) {
                    logBlocked('SSLSocket', 'CREATE_LOCAL', addrStr, blockMatch);
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                var newHost = rewriteHostIfNeeded('SSLSocket', 'CREATE_LOCAL', host);
                if (newHost !== host) {
                    Log.i(netLogTag, 'SSL.CREATE_LOCAL ' + newHost + ':' + port);
                    return this.createSocket(newHost, port, localAddr, localPort);
                }

                Log.i(netLogTag, 'SSL.CREATE_LOCAL ' + addrStr);
                return this.createSocket(host, port, localAddr, localPort);
            };
        } catch (err) { }

        console.log('[*] Network blocking + monitoring hooks installed');
        console.log('[*] Block rules: ' + blockPatterns.length + ', Rewrite rules: ' + rewriteRules.length);
        console.log('======================================================');
        console.log('[#] HSPatch: All bypass modules active                [#]');
        console.log('======================================================');
    });
}, 0);
