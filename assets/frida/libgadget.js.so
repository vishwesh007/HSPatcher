/*
 * HSPatch Universal Frida Script v3.0
 * - SSL Certificate Pinning Bypass
 * - Signature Verification Bypass (runtime layer)
 * - Piracy / License / Integrity Checks Removal
 * - Screenshot / Recording FLAG_SECURE Bypass
 * - Network Traffic Monitoring, Blocking & Modification
 */

setTimeout(function() {
    Java.perform(function() {
        var TAG = "HSPatch-Frida";

        console.log('');
        console.log('======================================================');
        console.log('[#] HSPatch Universal Bypass Suite v3.0               [#]');
        console.log('======================================================');

        // =====================================================
        // 1. SSL CERTIFICATE PINNING BYPASS
        // =====================================================

        // TrustManagerImpl
        try {
            var array_list = Java.use('java.util.ArrayList');
            var TrustManagerImpl = Java.use('com.android.org.conscrypt.TrustManagerImpl');
            TrustManagerImpl.checkTrustedRecursive.implementation = function(a, b, c, d, e, f, g, h) {
                console.log('[+] SSL: Bypassing TrustManagerImpl for: ' + b);
                return array_list.$new();
            };
        } catch (err) {
            console.log('[-] TrustManagerImpl not found');
        }

        // OpenSSLSocketImpl
        try {
            var OpenSSLSocketImpl = Java.use('com.android.org.conscrypt.OpenSSLSocketImpl');
            OpenSSLSocketImpl.verifyCertificateChain.implementation = function(g, i) {
                console.log('[+] SSL: Bypassing OpenSSLSocketImpl');
            };
        } catch (err) {
            console.log('[-] OpenSSLSocketImpl not found');
        }

        // OkHttp3 CertificatePinner
        try {
            var CertPinner = Java.use('okhttp3.CertificatePinner');
            CertPinner.check.overload('java.lang.String', 'java.util.List').implementation = function(hostname, peerCerts) {
                console.log('[+] SSL: Bypassing OkHttp3 CertificatePinner for: ' + hostname);
            };
        } catch (err) { }

        try {
            var CertPinner2 = Java.use('okhttp3.CertificatePinner');
            CertPinner2['check$okhttp'].implementation = function(hostname, fn) {
                console.log('[+] SSL: Bypassing OkHttp3 CertificatePinner$okhttp for: ' + hostname);
            };
        } catch (err) { }

        // TrustManagerFactory
        try {
            var TrustManagerFactory = Java.use('javax.net.ssl.TrustManagerFactory');
            TrustManagerFactory.getTrustManagers.implementation = function() {
                var EmptyTrustManager = Java.registerClass({
                    name: 'com.hspatch.TrustAllManager',
                    implements: [Java.use('javax.net.ssl.X509TrustManager')],
                    methods: {
                        checkClientTrusted: function(chain, authType) {},
                        checkServerTrusted: function(chain, authType) {},
                        getAcceptedIssuers: function() { return []; }
                    }
                });
                return [EmptyTrustManager.$new()];
            };
        } catch (err) { }

        // HttpsURLConnection default hostname verifier
        try {
            var HostnameVerifier = Java.registerClass({
                name: 'com.hspatch.GlobalHostnameVerifier',
                implements: [Java.use('javax.net.ssl.HostnameVerifier')],
                methods: {
                    verify: function(hostname, session) { return true; }
                }
            });
            var HttpsURLConnection = Java.use('javax.net.ssl.HttpsURLConnection');
            HttpsURLConnection.setDefaultHostnameVerifier.implementation = function(verifier) {
                this.setDefaultHostnameVerifier(HostnameVerifier.$new());
            };
        } catch (err) { }

        console.log('[*] SSL Pinning bypass hooks installed');


        // =====================================================
        // 2. SIGNATURE VERIFICATION BYPASS (Runtime Layer)
        // =====================================================

        // Hook PackageManager.getPackageInfo to fix signatures
        try {
            var PM = Java.use('android.app.ApplicationPackageManager');

            PM.getPackageInfo.overload('java.lang.String', 'int').implementation = function(name, flags) {
                var pi = this.getPackageInfo(name, flags);

                // Only patch our own package
                var ctx = Java.use('android.app.ActivityThread').currentApplication();
                if (ctx !== null && name === ctx.getPackageName()) {
                    if ((flags & 0x40) !== 0 || (flags & 0x8000000) !== 0) {
                        try {
                            var storedSigs = Java.use('in.startv.hotstar.SignatureBypass').originalSignatures.value;
                            if (storedSigs !== null) {
                                pi.signatures.value = storedSigs;
                                console.log('[+] SIG: Patched getPackageInfo signatures for ' + name);
                            }
                        } catch(e) {}
                    }
                }
                return pi;
            };
            console.log('[*] Signature bypass hooks installed');
        } catch (err) {
            console.log('[-] PackageManager signature hook: ' + err);
        }


        // =====================================================
        // 3. PIRACY / LICENSE / INTEGRITY CHECK REMOVAL
        // =====================================================

        // Google Play Licensing (LVL)
        try {
            var LicenseChecker = Java.use('com.google.android.vending.licensing.LicenseChecker');
            LicenseChecker.checkAccess.implementation = function(callback) {
                console.log('[+] PIRACY: Bypassing LicenseChecker.checkAccess');
                try { callback.allow(0x100); } catch(e) { callback.allow(); }
            };
        } catch (err) { }

        // Installer package check bypass
        try {
            var APM = Java.use('android.app.ApplicationPackageManager');
            APM.getInstallerPackageName.implementation = function(pkg) {
                console.log('[+] PIRACY: Spoofing installer to Play Store for: ' + pkg);
                return "com.android.vending";
            };
        } catch (err) { }

        // Debug detection bypass
        try {
            var Debug = Java.use('android.os.Debug');
            Debug.isDebuggerConnected.implementation = function() { return false; };
        } catch (err) { }

        // Root detection - block common su checks
        try {
            var Runtime = Java.use('java.lang.Runtime');
            var origExec = Runtime.exec.overload('java.lang.String');
            origExec.implementation = function(cmd) {
                if (cmd.indexOf('su') === 0 || cmd === 'which su' ||
                    cmd.indexOf('/system/xbin/su') !== -1 ||
                    cmd.indexOf('/system/bin/su') !== -1 ||
                    cmd.indexOf('busybox') !== -1) {
                    console.log('[+] ROOT: Blocking root detection exec: ' + cmd);
                    throw Java.use('java.io.IOException').$new('Permission denied');
                }
                return origExec.call(this, cmd);
            };
        } catch (err) { }

        // Root detection - hide known root paths
        try {
            var File = Java.use('java.io.File');
            var origExists = File.exists;
            File.exists.implementation = function() {
                var path = this.getAbsolutePath();
                var rootPaths = ['/system/app/Superuser.apk', '/system/xbin/su', '/system/bin/su',
                    '/sbin/su', '/data/local/xbin/su', '/data/local/bin/su',
                    '/su/bin/su', '/data/adb/magisk'];
                for (var i = 0; i < rootPaths.length; i++) {
                    if (path === rootPaths[i]) {
                        console.log('[+] ROOT: Hiding path: ' + path);
                        return false;
                    }
                }
                return origExists.call(this);
            };
        } catch (err) { }

        // Build.TAGS - release-keys
        try {
            var Build = Java.use('android.os.Build');
            var tags = Build.TAGS.value;
            if (tags && tags.indexOf('test-keys') !== -1) {
                Build.TAGS.value = 'release-keys';
                console.log('[+] ROOT: Changed Build.TAGS to release-keys');
            }
        } catch (err) { }

        console.log('[*] Piracy/License/Root bypass hooks installed');


        // =====================================================
        // 4. SCREENSHOT & RECORDING ENABLEMENT
        // =====================================================

        try {
            var Window = Java.use('android.view.Window');
            Window.setFlags.implementation = function(flags, mask) {
                var cleanFlags = flags & ~0x2000;
                var cleanMask = mask & ~0x2000;
                if (flags !== cleanFlags) {
                    console.log('[+] SCREEN: Stripped FLAG_SECURE from setFlags');
                }
                this.setFlags(cleanFlags, cleanMask);
            };

            Window.addFlags.implementation = function(flags) {
                var cleanFlags = flags & ~0x2000;
                if (flags !== cleanFlags) {
                    console.log('[+] SCREEN: Stripped FLAG_SECURE from addFlags');
                }
                this.addFlags(cleanFlags);
            };
        } catch (err) {
            console.log('[-] Window FLAG_SECURE hook: ' + err);
        }

        // SurfaceView.setSecure
        try {
            var SurfaceView = Java.use('android.view.SurfaceView');
            SurfaceView.setSecure.implementation = function(isSecure) {
                console.log('[+] SCREEN: Bypassing SurfaceView.setSecure(' + isSecure + ')');
                this.setSecure(false);
            };
        } catch (err) { }

        console.log('[*] Screenshot/Recording bypass hooks installed');


        // =====================================================
        // 5. NETWORK TRAFFIC BLOCKING, MODIFICATION & MONITORING
        // =====================================================

        var netLogTag = "HSPatch-Net";
        var Log = Java.use('android.util.Log');

        // --- Load blocking rules from blocking_hotstar.txt ---
        // Rules format: each line is "pattern:replacement"
        // If replacement is empty or "BLOCK", the request is fully blocked.
        // Otherwise, pattern is replaced with replacement in the URL.
        var blockRules = [];
        var blockPatterns = [];   // patterns with no replacement → full block
        var rewriteRules = [];   // patterns with replacement → URL rewrite

        function loadBlockingRules() {
            try {
                var ctx = Java.use('android.app.ActivityThread').currentApplication();
                if (ctx === null) return;

                // Try external files dir first, then fallback paths
                var paths = [];
                try {
                    var extDir = ctx.getExternalFilesDir(null);
                    if (extDir !== null) {
                        paths.push(extDir.getAbsolutePath() + '/blocking_hotstar.txt');
                    }
                } catch(e) {}
                try {
                    var dataDir = ctx.getApplicationInfo().dataDir.value;
                    paths.push(dataDir + '/files/blocking_hotstar.txt');
                } catch(e) {}
                paths.push('/storage/emulated/0/Download/hspatch_logs/blocking_hotstar.txt');

                var File = Java.use('java.io.File');
                var BufferedReader = Java.use('java.io.BufferedReader');
                var FileReader = Java.use('java.io.FileReader');

                for (var pi = 0; pi < paths.length; pi++) {
                    var f = File.$new(paths[pi]);
                    if (f.exists()) {
                        Log.i(netLogTag, '[RULES] Loading blocking rules from: ' + paths[pi]);
                        var reader = BufferedReader.$new(FileReader.$new(paths[pi]));
                        var line;
                        while ((line = reader.readLine()) !== null) {
                            var lineStr = line.toString().trim();
                            if (lineStr.length === 0 || lineStr.charAt(0) === '#') continue;

                            var sepIdx = lineStr.indexOf(':');
                            if (sepIdx > 0) {
                                var pattern = lineStr.substring(0, sepIdx).trim();
                                var replacement = lineStr.substring(sepIdx + 1).trim();
                                if (replacement.length === 0 || replacement === 'BLOCK') {
                                    blockPatterns.push(pattern);
                                    Log.i(netLogTag, '[RULES]   BLOCK: ' + pattern);
                                } else {
                                    rewriteRules.push({ from: pattern, to: replacement });
                                    Log.i(netLogTag, '[RULES]   REWRITE: ' + pattern + ' -> ' + replacement);
                                }
                            } else {
                                // No colon = treat entire line as a block pattern
                                blockPatterns.push(lineStr);
                                Log.i(netLogTag, '[RULES]   BLOCK: ' + lineStr);
                            }
                        }
                        reader.close();
                        Log.i(netLogTag, '[RULES] Loaded ' + blockPatterns.length + ' block rules + '
                            + rewriteRules.length + ' rewrite rules');
                        break; // found and loaded
                    }
                }
                if (blockPatterns.length === 0 && rewriteRules.length === 0) {
                    Log.i(netLogTag, '[RULES] No blocking rules file found (will only monitor)');
                }
            } catch (err) {
                Log.w(netLogTag, '[RULES] Failed to load rules: ' + err);
            }
        }

        // Reload rules periodically (every 60s) so user edits take effect
        function scheduleRuleReload() {
            setTimeout(function() {
                Java.perform(function() {
                    var oldBlock = blockPatterns.length;
                    var oldRewrite = rewriteRules.length;
                    blockPatterns = [];
                    rewriteRules = [];
                    loadBlockingRules();
                    if (blockPatterns.length !== oldBlock || rewriteRules.length !== oldRewrite) {
                        Log.i(netLogTag, '[RULES] Rules reloaded: ' + blockPatterns.length + ' block, '
                            + rewriteRules.length + ' rewrite');
                    }
                });
                scheduleRuleReload();
            }, 60000);
        }

        loadBlockingRules();
        scheduleRuleReload();

        // Check if a URL should be blocked (returns true if blocked)
        function shouldBlock(url) {
            for (var i = 0; i < blockPatterns.length; i++) {
                if (url.indexOf(blockPatterns[i]) !== -1) {
                    return blockPatterns[i];
                }
            }
            return null;
        }

        // Apply rewrite rules to URL, returns modified URL string
        function applyRewrites(url) {
            var modified = url;
            for (var i = 0; i < rewriteRules.length; i++) {
                if (modified.indexOf(rewriteRules[i].from) !== -1) {
                    var before = modified;
                    modified = modified.split(rewriteRules[i].from).join(rewriteRules[i].to);
                    Log.i(netLogTag, '[REWRITE] ' + rewriteRules[i].from + ' -> ' + rewriteRules[i].to + ' in ' + before);
                }
            }
            return modified;
        }

        // Log blocked request
        function logBlocked(source, method, url, pattern) {
            Log.i(netLogTag, '[BLOCKED] [' + source + '] ' + method + ' ' + url + ' (matched: ' + pattern + ')');
            // Also log to file via NetworkLogger if available
            try {
                var NL = Java.use('in.startv.hotstar.NetworkLogger');
                NL.log('[BLOCKED] [' + source + '] ' + method + ' ' + url + ' (matched: ' + pattern + ')');
            } catch(e) {}

            // Also log to blocked_urls.txt
            try {
                var HSConfig = Java.use('in.startv.hotstar.HSPatchConfig');
                var blockedPath = HSConfig.getFilePath('blocked_urls.txt');
                var fw = Java.use('java.io.FileWriter').$new(blockedPath, true);
                var ts = Java.use('java.text.SimpleDateFormat').$new('HH:mm:ss')
                    .format(Java.use('java.util.Date').$new());
                fw.write(ts + ' [' + source + '] ' + method + ' ' + url + '\n');
                fw.flush();
                fw.close();
            } catch(e2) {}
        }

        // URL.openConnection() — block or rewrite before connection opens
        try {
            var URL = Java.use('java.net.URL');
            URL.openConnection.overload().implementation = function() {
                var url = this.toString();

                // Check block rules
                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('URL', 'OPEN', url, blockMatch);
                    // Return connection to localhost to effectively null-route
                    var nullUrl = Java.use('java.net.URL').$new('http://127.0.0.1:1/blocked');
                    return nullUrl.openConnection();
                }

                // Apply rewrite rules
                var rewritten = applyRewrites(url);
                if (rewritten !== url) {
                    Log.i(netLogTag, '[URL.open] REWRITTEN: ' + url + ' -> ' + rewritten);
                    var newUrl = Java.use('java.net.URL').$new(rewritten);
                    return newUrl.openConnection();
                }

                Log.i(netLogTag, 'OPEN ' + url);
                return this.openConnection();
            };
        } catch (err) { }

        // OkHttp3 — intercept newCall, block or rewrite request URL
        try {
            var OkHttpClient = Java.use('okhttp3.OkHttpClient');
            OkHttpClient.newCall.implementation = function(request) {
                var url = request.url().toString();
                var method = request.method();

                // Check block rules
                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('OkHttp3', method, url, blockMatch);
                    // Build a new request to localhost to null-route
                    var Builder = Java.use('okhttp3.Request$Builder');
                    var HttpUrl = Java.use('okhttp3.HttpUrl');
                    var blockedUrl = HttpUrl.parse('http://127.0.0.1:1/blocked');
                    var blockedReq = request.newBuilder().url(blockedUrl).build();
                    return this.newCall(blockedReq);
                }

                // Apply rewrite rules
                var rewritten = applyRewrites(url);
                if (rewritten !== url) {
                    Log.i(netLogTag, '[OkHttp3] REWRITTEN: ' + method + ' ' + url + ' -> ' + rewritten);
                    var HttpUrl2 = Java.use('okhttp3.HttpUrl');
                    var newHttpUrl = HttpUrl2.parse(rewritten);
                    if (newHttpUrl !== null) {
                        var newReq = request.newBuilder().url(newHttpUrl).build();
                        return this.newCall(newReq);
                    }
                }

                Log.i(netLogTag, 'REQ ' + method + ' ' + url);
                return this.newCall(request);
            };
        } catch (err) { }

        // HttpURLConnection — block before connect
        try {
            var HttpURLConnection = Java.use('java.net.HttpURLConnection');
            HttpURLConnection.connect.implementation = function() {
                var url = this.getURL().toString();

                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('HttpConn', 'CONN', url, blockMatch);
                    // Throw IOException to prevent the connection
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                Log.i(netLogTag, 'CONN ' + url);
                this.connect();
            };
        } catch (err) { }

        // WebView URL — block before loading
        try {
            var WebView = Java.use('android.webkit.WebView');
            WebView.loadUrl.overload('java.lang.String').implementation = function(url) {
                var blockMatch = shouldBlock(url);
                if (blockMatch !== null) {
                    logBlocked('WebView', 'LOAD', url, blockMatch);
                    // Load blank page instead
                    this.loadUrl('about:blank');
                    return;
                }

                var rewritten = applyRewrites(url);
                if (rewritten !== url) {
                    Log.i(netLogTag, '[WebView] REWRITTEN: ' + url + ' -> ' + rewritten);
                    this.loadUrl(rewritten);
                    return;
                }

                Log.i(netLogTag, 'WEBVIEW ' + url);
                this.loadUrl(url);
            };
        } catch (err) { }

        // Socket connect — block by host pattern
        try {
            var Socket = Java.use('java.net.Socket');
            Socket.connect.overload('java.net.SocketAddress', 'int').implementation = function(addr, timeout) {
                var addrStr = addr.toString();

                var blockMatch = shouldBlock(addrStr);
                if (blockMatch !== null) {
                    logBlocked('Socket', 'CONNECT', addrStr, blockMatch);
                    throw Java.use('java.io.IOException').$new('HSPatch: blocked by rule: ' + blockMatch);
                }

                Log.i(netLogTag, 'SOCKET ' + addrStr);
                this.connect(addr, timeout);
            };
        } catch (err) { }

        console.log('[*] Network blocking + monitoring hooks installed');
        console.log('[*] Block rules: ' + blockPatterns.length + ', Rewrite rules: ' + rewriteRules.length);
        console.log('======================================================');
        console.log('[#] HSPatch: All bypass modules active                [#]');
        console.log('======================================================');
    });
}, 0);
